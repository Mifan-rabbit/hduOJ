>### Problem Description<br>
>穿过幽谷意味着离大魔王lemon已经无限接近了！<br>
>可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！<br>
>可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！<br>
>命运大迷宫可以看成是一个两维的方格阵列，如下图所示：<br>
>
>||1|2|3|4|5|6|7|8|
>|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
>|1|+9|+10|+10|+10|+10|-10|+10|+10|
>|2|+10|-11|-1|+0|+2|+11|+10|-20|
>|3|-11|-11|+10|+11|+2|+10|-10|-10|
>
><br>
>yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。<br>
>现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k>1。<br>
>为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。<br>
><br>
>### Input<br>
>输入数据首先是一个整数C，表示测试数据的组数。<br>
>每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1<=n<=20,10<=m<=1000)；<br>
>接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|<100 )。<br>
> <br>
>### Output<br>
>请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。<br>
> <br>
>### Sample Input<br>
>1<br>
>3 8<br>
>9 10 10 10 10 -10 10 10<br>
>10 -11 -1 0 2 11 10 -20<br>
>-11 -11 10 11 2 10 -10 -10<br>
> <br>
>### Sample Output<br>
>52<br>

```cpp
#include <iostream>
using namespace std;

int max(int a, int b)
{
    return a > b ? a : b;
}

int main()
{
    int map[22][1002], dp[22][1002];
    int T, m, n; //m行，n列
    cin >> T;
    while (T--)
    {
        cin >> m >> n;
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                cin >> map[i][j];
            }
        }
        for (int i = 0; i <= m; i++)//可能为负
        {
            dp[i][0] = -999;
        }
        for (int i = 0; i <= n; i++)
        {
            dp[0][i] = -999;
        }
        dp[0][1] = dp[1][0] = 0;
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);//向右走到or向下走到
                for (int k = 1; k < j; k++) //从1开始
                {
                    if (j % k == 0)
                    {
                        dp[i][j] = max(dp[i][j], dp[i][k]);
                    }
                }
                dp[i][j] += map[i][j];
            }
        }
        cout << dp[m][n] << endl;
    }
    return 0;
}
```
